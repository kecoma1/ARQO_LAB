Tengo 4 cores normales
Tengo 8 cores virtuales

EJ 0:
cat /proc/cpuinfo
    coger el cpu cores del cluster
    coger siblings del cluster
    
EJ 1:
    1.1. Yes it is possible. Yes it makes sense because you can be able to have multiple programs running at the same time.
    1.2.    ---- COMPROBAR NUMERO DE CORES EN EL ORDENA DE LA UNI
            ---- COMPROBAR NUMERO DE CORES EN EL cluster
            4 because my computer has 4 cores.
    1.3. The one with the highest priority is #pragma omp parallel num_threads(numthr), this is set before the creation of the threads. Then we have the function omp_set_num_threads(int num_threads), this function is called in the program before #pragma... the call of this function overwrites the value in OMP_NUM_THREADS. Finally, we have the last which is the ENVIROMENT variable, if we create a program which uses x threads and then we change the variable to y, the program wont change, once it's created it wont change (even when you change the value before the pragma creates the threades).
    1.4. It depends on which type of "privacy", if it is just private, each thread creates a copy of the variable but its initialized to 0, if you use firstprivate each thread has a copy of the variable but it also has the same value at the beggining.
    1.5. OMP creates a copy and initialise the variable to 0, if you used the normal private, but if you use the firstprivate the value is maintained
    1.6. As threads use copies of the variables the original variable remains the same.
    1.7. No, it depends on if the threads change the value.

EJ 2:
    2.1. The bigger the size, the bigger the time the function spends it. It has one loop, so the time to sum is linear, depends on the size.
    2.2. There's a problem with concurrence, the variable sum is read and written by all the threads, so the result is wrong.
    2.3 Yes it can be solved with both directives
        #pragma omp parallel for
        for(k=0;k<M;k++) {
            #pragma omp atomic
	    	sum = sum + A[k]*B[k];
    	}

        #pragma omp parallel for 
        for(k=0;k<M;k++) {
            #pragma omp critical 
            {
	    	    sum = sum + A[k]*B[k];
            }
        }
        As we are only executing one operation, making it atomic is our chosen option

    2.4. We will choose the reduction option, because it is the fastest, and it is the fastest because with the previous options we were preventing from concurrence problems the entire operation (+ and *) but we only need to protect from concurence the addition of the variable sum.
    2.5 EJECUTAR EN EL CLUSTER, CAMBIANDO EL NUMERO DE THREADS DEPENDIENDO DEL NUMERO DE CORES DEL NODO CLUSTER
    No, it is not always worth, for example, having a size of 40.000 and 2 threads makes the computation slower than computing without paralelism. 
    For sizes smaller than 40.000 having paralelism means that there is "too many people" working in the task. Open mp has to manage all the threads and that requires resources.
    No it is not, depending on the size of the task we may need a number x of threads to make the performance optimal, otherwise, the computation will be worse.
    ----Generar charts y responder ultima pregunta 2.5
    
